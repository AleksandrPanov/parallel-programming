#include<mpi.h>
#include<iostream>
#include "Matrix.h"
#include <cassert>
#include <algorithm>
#define tag 0
#define col1 row
using namespace std;
char *read = "in.txt", *write = "out.txt";
Matrix getSolveLow(Matrix & A, Matrix & f)
{
	Matrix ans(A.gRow(), 1);
	for (int i = 0; i < A.gRow(); i++)
	{
		double tmp = f[i][0];
		for (int j = 0; j < i; j++)
			tmp -= A[i][j] * ans[j][0];
		ans[i][0] = tmp / A[i][i];
	}
	return ans;
}
Matrix getF(Matrix &m, Matrix &x, Matrix &f, int start, int end) //(0 x2) * -xx1 + f1 
{																  //(0  0) * -xx2 + f2
	assert(x.gCol() == 1 && f.gCol() == 1 && m.gRow() == x.gRow() && m.gRow() == f.gRow());
	int row = m.gRow();
	int col = m.gCol();
	Matrix newF(row, 1);
	for (int i = start; i < end; i++)
	{
		newF[i][0] += f[i][0];
		for (int j = i + 1; j < col; j++)
			newF[i][0] -= m[i][j] * x[j][0];
	}
	return newF;
}
double* readSystem(int &len)
{
	freopen(read, "r", stdin);
	scanf("%d", &len);
	double *p = new double[len*len + len];
	for (int i = 0; i < len*len + len; i++)
		scanf("%lf", p+i);
	return p;
}
void setAf(double *p, int len, Matrix& A, Matrix &f)
{

}
int getSizeTask1(int &lastRow, int nProc)
{
	int ans = lastRow % nProc + lastRow / nProc;
	lastRow -= ans;
	return ans;
}
int main(int argc, char **argv)
{
	int rank, nProc, row = 0, curRow = 0;
	Matrix A, F;
	MPI_Status status;
	MPI_Init(&argc, &argv);
	double *p;
	double *f;
	int numRow;
	MPI_Comm_size(MPI_COMM_WORLD, &nProc);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	if (rank == 0)
	{
		//read file
		p = readSystem(row);
		A = Matrix(row,row, p);	F= Matrix(row, 1, p + row*row);
		cout << A << F;
		int lastRow = row;
		numRow = getSizeTask1(lastRow, nProc);
		A = Matrix(numRow, row, p);	F = Matrix(numRow, 1, p + row*row);
		int curRow = numRow;
		for (int i = 1; i < nProc; i++)
		{
			int numRow = getSizeTask1(lastRow, nProc);
			MPI_Send(&row, 1, MPI_INT, i, tag, MPI_COMM_WORLD);
			MPI_Send(&numRow, 1, MPI_INT, i, tag, MPI_COMM_WORLD);
			MPI_Send(&curRow, 1, MPI_INT, i, tag, MPI_COMM_WORLD);
			MPI_Send(p + curRow*col1, numRow*col1, MPI_DOUBLE, i, tag, MPI_COMM_WORLD);
			MPI_Send(p + row*row + curRow, numRow, MPI_DOUBLE, i, tag, MPI_COMM_WORLD);
			curRow += numRow;
		}
	}
	else
	{
		MPI_Recv(&row, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &status);
		MPI_Recv(&numRow, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &status);
		MPI_Recv(&curRow, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &status);
		p = new double[row*numRow];
		f = new double[row];
		MPI_Recv(p, row*numRow, MPI_DOUBLE, 0, tag, MPI_COMM_WORLD, &status);
		MPI_Recv(f, row, MPI_DOUBLE, 0, tag, MPI_COMM_WORLD, &status);
		A = Matrix(numRow, row, p);
		F = Matrix(numRow, 1, f);
	//	cout <<"matrix\n"<< A << F;
	}
	//Matrix nF = Matrix
	//считаем свои х
	//BCAST для 0 процесса отправить всем x0, x1, ...;

	cout << "The number of my row: " << curRow << " my number is " << rank << '\n' << A << F;
	MPI_Finalize();
	return 0;
}